import { Injectable, Inject, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
const DEGREE_IN_RADIANS = Math.PI / 180;
export class RoundProgressService {
    constructor(document) {
        this.supportsSvg = !!(document &&
            document.createElementNS &&
            document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);
        this.base = document && document.head.querySelector('base');
        this.hasPerf =
            typeof window !== 'undefined' &&
                window.performance &&
                window.performance.now &&
                typeof window.performance.now() === 'number';
    }
    /**
     * Resolves a SVG color against the page's `base` tag.
     */
    resolveColor(color) {
        if (this.base && this.base.href) {
            const hashIndex = color.indexOf('#');
            if (hashIndex > -1 && color.indexOf('url') > -1) {
                return color.slice(0, hashIndex) + location.href + color.slice(hashIndex);
            }
        }
        return color;
    }
    /**
     * Generates a timestamp.
     */
    getTimestamp() {
        return this.hasPerf ? window.performance.now() : Date.now();
    }
    /**
     * Generates the value for an SVG arc.
     *
     * @param current Current value.
     * @param total Maximum value.
     * @param pathRadius Radius of the SVG path.
     * @param elementRadius Radius of the SVG container.
     * @param isSemicircle Whether the element should be a semicircle.
     */
    getArc(current, total, pathRadius, elementRadius, isSemicircle = false) {
        const value = Math.max(0, Math.min(current || 0, total));
        const maxAngle = isSemicircle ? 180 : 359.9999;
        const percentage = total === 0 ? maxAngle : (value / total) * maxAngle;
        const start = this._polarToCartesian(elementRadius, pathRadius, percentage);
        const end = this._polarToCartesian(elementRadius, pathRadius, 0);
        const arcSweep = percentage <= 180 ? 0 : 1;
        return `M ${start} A ${pathRadius} ${pathRadius} 0 ${arcSweep} 0 ${end}`;
    }
    /**
     * Converts polar cooradinates to Cartesian.
     *
     * @param elementRadius Radius of the wrapper element.
     * @param pathRadius Radius of the path being described.
     * @param angleInDegrees Degree to be converted.
     */
    _polarToCartesian(elementRadius, pathRadius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
        const x = elementRadius + pathRadius * Math.cos(angleInRadians);
        const y = elementRadius + pathRadius * Math.sin(angleInRadians);
        return x + ' ' + y;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: RoundProgressService, deps: [{ token: DOCUMENT, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: RoundProgressService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: RoundProgressService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQtcHJvZ3Jlc3Muc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvcm91bmQtcHJvZ3Jlc3Mvcm91bmQtcHJvZ3Jlc3Muc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDM0QsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDOztBQUV6QyxNQUFNLGlCQUFpQixHQUFXLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDO0FBR2hELE1BQU0sT0FBTyxvQkFBb0I7SUFLL0IsWUFBMEMsUUFBYTtRQUNyRCxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxDQUNuQixRQUFRO1lBQ1IsUUFBUSxDQUFDLGVBQWU7WUFDeEIsUUFBUSxDQUFDLGVBQWUsQ0FBQyw0QkFBNEIsRUFBRSxLQUFLLENBQUMsQ0FBQyxhQUFhLENBQzVFLENBQUM7UUFFRixJQUFJLENBQUMsSUFBSSxHQUFHLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1RCxJQUFJLENBQUMsT0FBTztZQUNWLE9BQU8sTUFBTSxLQUFLLFdBQVc7Z0JBQzdCLE1BQU0sQ0FBQyxXQUFXO2dCQUNsQixNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUc7Z0JBQ3RCLE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxRQUFRLENBQUM7SUFDakQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsWUFBWSxDQUFDLEtBQWE7UUFDeEIsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQy9CLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFckMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtnQkFDL0MsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDM0U7U0FDRjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsWUFBWTtRQUNWLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQzlELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILE1BQU0sQ0FBQyxPQUFlLEVBQUUsS0FBYSxFQUFFLFVBQWtCLEVBQUUsYUFBcUIsRUFDekUsWUFBWSxHQUFHLEtBQUs7UUFDekIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDekQsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUMvQyxNQUFNLFVBQVUsR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUN2RSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUM1RSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNqRSxNQUFNLFFBQVEsR0FBRyxVQUFVLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUzQyxPQUFPLEtBQUssS0FBSyxNQUFNLFVBQVUsSUFBSSxVQUFVLE1BQU0sUUFBUSxNQUFNLEdBQUcsRUFBRSxDQUFDO0lBQzNFLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxpQkFBaUIsQ0FBQyxhQUFxQixFQUFFLFVBQWtCLEVBQ3pDLGNBQXNCO1FBQzlDLE1BQU0sY0FBYyxHQUFHLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQyxHQUFHLGlCQUFpQixDQUFDO1FBQ2pFLE1BQU0sQ0FBQyxHQUFHLGFBQWEsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNoRSxNQUFNLENBQUMsR0FBRyxhQUFhLEdBQUcsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFaEUsT0FBTyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNyQixDQUFDOzhHQTdFVSxvQkFBb0Isa0JBS0MsUUFBUTtrSEFMN0Isb0JBQW9CLGNBRFIsTUFBTTs7MkZBQ2xCLG9CQUFvQjtrQkFEaEMsVUFBVTttQkFBQyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUM7OzBCQU1qQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWx9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuY29uc3QgREVHUkVFX0lOX1JBRElBTlM6IG51bWJlciA9IE1hdGguUEkgLyAxODA7XG5cbkBJbmplY3RhYmxlKHtwcm92aWRlZEluOiAncm9vdCd9KVxuZXhwb3J0IGNsYXNzIFJvdW5kUHJvZ3Jlc3NTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBiYXNlOiBIVE1MQmFzZUVsZW1lbnQ7XG4gIHByaXZhdGUgaGFzUGVyZjogYm9vbGVhbjtcbiAgcHVibGljIHN1cHBvcnRzU3ZnOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIGRvY3VtZW50OiBhbnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzU3ZnID0gISEoXG4gICAgICBkb2N1bWVudCAmJlxuICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmXG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpLmNyZWF0ZVNWR1JlY3RcbiAgICApO1xuXG4gICAgdGhpcy5iYXNlID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgdGhpcy5oYXNQZXJmID1cbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UgJiZcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgPT09ICdudW1iZXInO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgU1ZHIGNvbG9yIGFnYWluc3QgdGhlIHBhZ2UncyBgYmFzZWAgdGFnLlxuICAgKi9cbiAgcmVzb2x2ZUNvbG9yKGNvbG9yOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmJhc2UgJiYgdGhpcy5iYXNlLmhyZWYpIHtcbiAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGNvbG9yLmluZGV4T2YoJyMnKTtcblxuICAgICAgaWYgKGhhc2hJbmRleCA+IC0xICYmIGNvbG9yLmluZGV4T2YoJ3VybCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yLnNsaWNlKDAsIGhhc2hJbmRleCkgKyBsb2NhdGlvbi5ocmVmICsgY29sb3Iuc2xpY2UoaGFzaEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdGltZXN0YW1wLlxuICAgKi9cbiAgZ2V0VGltZXN0YW1wKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaGFzUGVyZiA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB2YWx1ZSBmb3IgYW4gU1ZHIGFyYy5cbiAgICpcbiAgICogQHBhcmFtIGN1cnJlbnQgQ3VycmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHRvdGFsIE1heGltdW0gdmFsdWUuXG4gICAqIEBwYXJhbSBwYXRoUmFkaXVzIFJhZGl1cyBvZiB0aGUgU1ZHIHBhdGguXG4gICAqIEBwYXJhbSBlbGVtZW50UmFkaXVzIFJhZGl1cyBvZiB0aGUgU1ZHIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIGlzU2VtaWNpcmNsZSBXaGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhIHNlbWljaXJjbGUuXG4gICAqL1xuICBnZXRBcmMoY3VycmVudDogbnVtYmVyLCB0b3RhbDogbnVtYmVyLCBwYXRoUmFkaXVzOiBudW1iZXIsIGVsZW1lbnRSYWRpdXM6IG51bWJlcixcbiAgICAgICAgIGlzU2VtaWNpcmNsZSA9IGZhbHNlKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnJlbnQgfHwgMCwgdG90YWwpKTtcbiAgICBjb25zdCBtYXhBbmdsZSA9IGlzU2VtaWNpcmNsZSA/IDE4MCA6IDM1OS45OTk5O1xuICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB0b3RhbCA9PT0gMCA/IG1heEFuZ2xlIDogKHZhbHVlIC8gdG90YWwpICogbWF4QW5nbGU7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9wb2xhclRvQ2FydGVzaWFuKGVsZW1lbnRSYWRpdXMsIHBhdGhSYWRpdXMsIHBlcmNlbnRhZ2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuX3BvbGFyVG9DYXJ0ZXNpYW4oZWxlbWVudFJhZGl1cywgcGF0aFJhZGl1cywgMCk7XG4gICAgY29uc3QgYXJjU3dlZXAgPSBwZXJjZW50YWdlIDw9IDE4MCA/IDAgOiAxO1xuXG4gICAgcmV0dXJuIGBNICR7c3RhcnR9IEEgJHtwYXRoUmFkaXVzfSAke3BhdGhSYWRpdXN9IDAgJHthcmNTd2VlcH0gMCAke2VuZH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHBvbGFyIGNvb3JhZGluYXRlcyB0byBDYXJ0ZXNpYW4uXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50UmFkaXVzIFJhZGl1cyBvZiB0aGUgd3JhcHBlciBlbGVtZW50LlxuICAgKiBAcGFyYW0gcGF0aFJhZGl1cyBSYWRpdXMgb2YgdGhlIHBhdGggYmVpbmcgZGVzY3JpYmVkLlxuICAgKiBAcGFyYW0gYW5nbGVJbkRlZ3JlZXMgRGVncmVlIHRvIGJlIGNvbnZlcnRlZC5cbiAgICovXG4gIHByaXZhdGUgX3BvbGFyVG9DYXJ0ZXNpYW4oZWxlbWVudFJhZGl1czogbnVtYmVyLCBwYXRoUmFkaXVzOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgYW5nbGVJblJhZGlhbnMgPSAoYW5nbGVJbkRlZ3JlZXMgLSA5MCkgKiBERUdSRUVfSU5fUkFESUFOUztcbiAgICBjb25zdCB4ID0gZWxlbWVudFJhZGl1cyArIHBhdGhSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgY29uc3QgeSA9IGVsZW1lbnRSYWRpdXMgKyBwYXRoUmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuXG4gICAgcmV0dXJuIHggKyAnICcgKyB5O1xuICB9XG59XG4iXX0=