import { Component, Input, Output, EventEmitter, ViewChild, Inject, ChangeDetectionStrategy, } from '@angular/core';
import { ROUND_PROGRESS_DEFAULTS } from './round-progress.config';
import * as i0 from "@angular/core";
import * as i1 from "./round-progress.service";
import * as i2 from "./round-progress.ease";
export class RoundProgressComponent {
    constructor(service, easing, defaults, ngZone) {
        this.service = service;
        this.easing = easing;
        this.defaults = defaults;
        this.ngZone = ngZone;
        this.currentLinecap = '';
        /** Current value of the progress bar. */
        this.current = 0;
        /** Maximum value of the progress bar. */
        this.max = 0;
        /** Radius of the circle. */
        this.radius = this.defaults.radius;
        /** Name of the easing function to use when animating. */
        this.animation = this.defaults.animation;
        /** Time in millisconds by which to delay the animation. */
        this.animationDelay = this.defaults.animationDelay;
        /** Duration of the animation. */
        this.duration = this.defaults.duration;
        /** Width of the circle's stroke. */
        this.stroke = this.defaults.stroke;
        /** Color of the circle. */
        this.color = this.defaults.color;
        /** Background color of the circle. */
        this.background = this.defaults.background;
        /** Whether the circle should take up the width of its parent. */
        this.responsive = this.defaults.responsive;
        /** Whether the circle is filling up clockwise. */
        this.clockwise = this.defaults.clockwise;
        /** Whether to render a semicircle. */
        this.semicircle = this.defaults.semicircle;
        /** Whether the tip of the progress should be rounded off. */
        this.rounded = this.defaults.rounded;
        /** Emits when a new value has been rendered. */
        this.onRender = new EventEmitter();
        this.lastAnimationId = 0;
    }
    /** Animates a change in the current value. */
    _animateChange(from, to) {
        if (typeof from !== 'number') {
            from = 0;
        }
        to = this._clamp(to);
        from = this._clamp(from);
        const self = this;
        const changeInValue = to - from;
        const duration = self.duration;
        // Avoid firing change detection for each of the animation frames.
        self.ngZone.runOutsideAngular(() => {
            const start = () => {
                const startTime = self.service.getTimestamp();
                const id = ++self.lastAnimationId;
                requestAnimationFrame(function animation() {
                    const currentTime = Math.min(self.service.getTimestamp() - startTime, duration);
                    const easingFn = self.easing[self.animation];
                    const value = easingFn(currentTime, from, changeInValue, duration);
                    self._updatePath(value);
                    if (self.onRender.observers.length > 0) {
                        self.onRender.emit(value);
                    }
                    if (id === self.lastAnimationId && currentTime < duration) {
                        requestAnimationFrame(animation);
                    }
                });
            };
            if (this.animationDelay > 0) {
                setTimeout(start, this.animationDelay);
            }
            else {
                start();
            }
        });
    }
    /** Updates the path apperance. */
    _updatePath(value) {
        if (this.path) {
            const arc = this.service.getArc(value, this.max, this.radius - this.stroke / 2, this.radius, this.semicircle);
            const path = this.path.nativeElement;
            // Remove the rounded line cap when the value is zero,
            // because SVG won't allow it to disappear completely.
            const linecap = this.rounded && value > 0 ? 'round' : '';
            // This is called on each animation frame so avoid
            // updating the line cap unless it has changed.
            if (linecap !== this.currentLinecap) {
                this.currentLinecap = linecap;
                path.style.strokeLinecap = linecap;
            }
            path.setAttribute('d', arc);
        }
    }
    /** Clamps a value between the maximum and 0. */
    _clamp(value) {
        return Math.max(0, Math.min(value || 0, this.max));
    }
    /** Determines the SVG transforms for the <path> node. */
    getPathTransform() {
        const diameter = this._getDiameter();
        if (this.semicircle) {
            return this.clockwise
                ? `translate(0, ${diameter}) rotate(-90)`
                : `translate(${diameter + ',' + diameter}) rotate(90) scale(-1, 1)`;
        }
        else if (!this.clockwise) {
            return `scale(-1, 1) translate(-${diameter} 0)`;
        }
        return null;
    }
    /** Resolves a color through the service. */
    resolveColor(color) {
        return this.service.resolveColor(color);
    }
    /** Change detection callback. */
    ngOnChanges(changes) {
        if (changes.current) {
            this._animateChange(changes.current.previousValue, changes.current.currentValue);
        }
        else {
            this._updatePath(this.current);
        }
    }
    /** Diameter of the circle. */
    _getDiameter() {
        return this.radius * 2;
    }
    /** The CSS height of the wrapper element. */
    _getElementHeight() {
        if (!this.responsive) {
            return (this.semicircle ? this.radius : this._getDiameter()) + 'px';
        }
        return null;
    }
    /** Viewbox for the SVG element. */
    _getViewBox() {
        const diameter = this._getDiameter();
        return `0 0 ${diameter} ${this.semicircle ? this.radius : diameter}`;
    }
    /** Bottom padding for the wrapper element. */
    _getPaddingBottom() {
        if (this.responsive) {
            return this.semicircle ? '50%' : '100%';
        }
        return null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: RoundProgressComponent, deps: [{ token: i1.RoundProgressService }, { token: i2.RoundProgressEase }, { token: ROUND_PROGRESS_DEFAULTS }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.5", type: RoundProgressComponent, isStandalone: true, selector: "round-progress", inputs: { current: "current", max: "max", radius: "radius", animation: "animation", animationDelay: "animationDelay", duration: "duration", stroke: "stroke", color: "color", background: "background", responsive: "responsive", clockwise: "clockwise", semicircle: "semicircle", rounded: "rounded" }, outputs: { onRender: "onRender" }, host: { attributes: { "role": "progressbar" }, properties: { "attr.aria-valuemin": "0", "attr.aria-valuemax": "max", "attr.aria-valuenow": "current", "style.width": "responsive ? \"\" : _getDiameter() + \"px\"", "style.height": "_getElementHeight()", "style.padding-bottom": "_getPaddingBottom()", "class.responsive": "responsive" } }, viewQueries: [{ propertyName: "path", first: true, predicate: ["path"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n", styles: [":host{display:block;position:relative;overflow:hidden}:host(.responsive){width:100%;padding-bottom:100%}:host(.responsive)>svg{position:absolute;width:100%;height:100%;top:0;left:0}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: RoundProgressComponent, decorators: [{
            type: Component,
            args: [{ selector: 'round-progress', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        'role': 'progressbar',
                        '[attr.aria-valuemin]': '0',
                        '[attr.aria-valuemax]': 'max',
                        '[attr.aria-valuenow]': 'current',
                        '[style.width]': 'responsive ? "" : _getDiameter() + "px"',
                        '[style.height]': '_getElementHeight()',
                        '[style.padding-bottom]': '_getPaddingBottom()',
                        '[class.responsive]': 'responsive',
                    }, standalone: true, template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n", styles: [":host{display:block;position:relative;overflow:hidden}:host(.responsive){width:100%;padding-bottom:100%}:host(.responsive)>svg{position:absolute;width:100%;height:100%;top:0;left:0}\n"] }]
        }], ctorParameters: () => [{ type: i1.RoundProgressService }, { type: i2.RoundProgressEase }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [ROUND_PROGRESS_DEFAULTS]
                }] }, { type: i0.NgZone }], propDecorators: { path: [{
                type: ViewChild,
                args: ['path']
            }], current: [{
                type: Input
            }], max: [{
                type: Input
            }], radius: [{
                type: Input
            }], animation: [{
                type: Input
            }], animationDelay: [{
                type: Input
            }], duration: [{
                type: Input
            }], stroke: [{
                type: Input
            }], color: [{
                type: Input
            }], background: [{
                type: Input
            }], responsive: [{
                type: Input
            }], clockwise: [{
                type: Input
            }], semicircle: [{
                type: Input
            }], rounded: [{
                type: Input
            }], onRender: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9yb3VuZC1wcm9ncmVzcy9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9zcmMvbGliL3JvdW5kLXByb2dyZXNzL3JvdW5kLXByb2dyZXNzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFHTixZQUFZLEVBQ1osU0FBUyxFQUNULE1BQU0sRUFHTix1QkFBdUIsR0FDeEIsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFDLHVCQUF1QixFQUF3QixNQUFNLHlCQUF5QixDQUFDOzs7O0FBb0J2RixNQUFNLE9BQU8sc0JBQXNCO0lBa0RqQyxZQUNVLE9BQTZCLEVBQzdCLE1BQXlCLEVBQ1EsUUFBK0IsRUFDaEUsTUFBYztRQUhkLFlBQU8sR0FBUCxPQUFPLENBQXNCO1FBQzdCLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBQ1EsYUFBUSxHQUFSLFFBQVEsQ0FBdUI7UUFDaEUsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQXJEaEIsbUJBQWMsR0FBaUIsRUFBRSxDQUFDO1FBSzFDLHlDQUF5QztRQUNoQyxZQUFPLEdBQVcsQ0FBQyxDQUFDO1FBRTdCLHlDQUF5QztRQUNoQyxRQUFHLEdBQVcsQ0FBQyxDQUFDO1FBRXpCLDRCQUE0QjtRQUNuQixXQUFNLEdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFPLENBQUM7UUFFaEQseURBQXlEO1FBQ2hELGNBQVMsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVUsQ0FBQztRQUV0RCwyREFBMkQ7UUFDbEQsbUJBQWMsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWUsQ0FBQztRQUVoRSxpQ0FBaUM7UUFDeEIsYUFBUSxHQUFXLElBQUksQ0FBQyxRQUFRLENBQUMs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QUFLO2dCQUdHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBR0csT0FBTztzQkFBZixLQUFLO2dCQUdJLFFBQVE7c0JBQWpCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIE9uQ2hhbmdlcyxcbiAgTmdab25lLFxuICBFdmVudEVtaXR0ZXIsXG4gIFZpZXdDaGlsZCxcbiAgSW5qZWN0LFxuICBFbGVtZW50UmVmLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7Um91bmRQcm9ncmVzc1NlcnZpY2V9IGZyb20gJy4vcm91bmQtcHJvZ3Jlc3Muc2VydmljZSc7XG5pbXBvcnQge1JPVU5EX1BST0dSRVNTX0RFRkFVTFRTLCBSb3VuZFByb2dyZXNzRGVmYXVsdHN9IGZyb20gJy4vcm91bmQtcHJvZ3Jlc3MuY29uZmlnJztcbmltcG9ydCB7Um91bmRQcm9ncmVzc0Vhc2V9IGZyb20gJy4vcm91bmQtcHJvZ3Jlc3MuZWFzZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3JvdW5kLXByb2dyZXNzJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlVXJsOiAnLi9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3JvdW5kLXByb2dyZXNzLmNvbXBvbmVudC5jc3MnXSxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnMCcsXG4gICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ21heCcsXG4gICAgJ1thdHRyLmFyaWEtdmFsdWVub3ddJzogJ2N1cnJlbnQnLFxuICAgICdbc3R5bGUud2lkdGhdJzogJ3Jlc3BvbnNpdmUgPyBcIlwiIDogX2dldERpYW1ldGVyKCkgKyBcInB4XCInLFxuICAgICdbc3R5bGUuaGVpZ2h0XSc6ICdfZ2V0RWxlbWVudEhlaWdodCgpJyxcbiAgICAnW3N0eWxlLnBhZGRpbmctYm90dG9tXSc6ICdfZ2V0UGFkZGluZ0JvdHRvbSgpJyxcbiAgICAnW2NsYXNzLnJlc3BvbnNpdmVdJzogJ3Jlc3BvbnNpdmUnLFxuICB9LFxuICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIFJvdW5kUHJvZ3Jlc3NDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBwcml2YXRlIGN1cnJlbnRMaW5lY2FwOiAncm91bmQnIHwgJycgPSAnJztcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGBwYXRoYCBub2RlLiAqL1xuICBAVmlld0NoaWxkKCdwYXRoJykgcGF0aCE6IEVsZW1lbnRSZWY8U1ZHUGF0aEVsZW1lbnQ+O1xuXG4gIC8qKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBiYXIuICovXG4gIEBJbnB1dCgpIGN1cnJlbnQ6IG51bWJlciA9IDA7XG5cbiAgLyoqIE1heGltdW0gdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhci4gKi9cbiAgQElucHV0KCkgbWF4OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBSYWRpdXMgb2YgdGhlIGNpcmNsZS4gKi9cbiAgQElucHV0KCkgcmFkaXVzOiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLnJhZGl1cyE7XG5cbiAgLyoqIE5hbWUgb2YgdGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlbiBhbmltYXRpbmcuICovXG4gIEBJbnB1dCgpIGFuaW1hdGlvbjogc3RyaW5nID0gdGhpcy5kZWZhdWx0cy5hbmltYXRpb24hO1xuXG4gIC8qKiBUaW1lIGluIG1pbGxpc2NvbmRzIGJ5IHdoaWNoIHRvIGRlbGF5IHRoZSBhbmltYXRpb24uICovXG4gIEBJbnB1dCgpIGFuaW1hdGlvbkRlbGF5OiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLmFuaW1hdGlvbkRlbGF5ITtcblxuICAvKiogRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi4gKi9cbiAgQElucHV0KCkgZHVyYXRpb246IG51bWJlciA9IHRoaXMuZGVmYXVsdHMuZHVyYXRpb24hO1xuXG4gIC8qKiBXaWR0aCBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLiAqL1xuICBASW5wdXQoKSBzdHJva2U6IG51bWJlciA9IHRoaXMuZGVmYXVsdHMuc3Ryb2tlITtcblxuICAvKiogQ29sb3Igb2YgdGhlIGNpcmNsZS4gKi9cbiAgQElucHV0KCkgY29sb3I6IHN0cmluZyA9IHRoaXMuZGVmYXVsdHMuY29sb3IhO1xuXG4gIC8qKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBjaXJjbGUuICovXG4gIEBJbnB1dCgpIGJhY2tncm91bmQ6IHN0cmluZyA9IHRoaXMuZGVmYXVsdHMuYmFja2dyb3VuZCE7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNpcmNsZSBzaG91bGQgdGFrZSB1cCB0aGUgd2lkdGggb2YgaXRzIHBhcmVudC4gKi9cbiAgQElucHV0KCkgcmVzcG9uc2l2ZTogYm9vbGVhbiA9IHRoaXMuZGVmYXVsdHMucmVzcG9uc2l2ZSE7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNpcmNsZSBpcyBmaWxsaW5nIHVwIGNsb2Nrd2lzZS4gKi9cbiAgQElucHV0KCkgY2xvY2t3aXNlOiBib29sZWFuID0gdGhpcy5kZWZhdWx0cy5jbG9ja3dpc2UhO1xuXG4gIC8qKiBXaGV0aGVyIHRvIHJlbmRlciBhIHNlbWljaXJjbGUuICovXG4gIEBJbnB1dCgpIHNlbWljaXJjbGU6IGJvb2xlYW4gPSB0aGlzLmRlZmF1bHRzLnNlbWljaXJjbGUhO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSB0aXAgb2YgdGhlIHByb2dyZXNzIHNob3VsZCBiZSByb3VuZGVkIG9mZi4gKi9cbiAgQElucHV0KCkgcm91bmRlZDogYm9vbGVhbiA9IHRoaXMuZGVmYXVsdHMucm91bmRlZCE7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVuZGVyZWQuICovXG4gIEBPdXRwdXQoKSBvblJlbmRlcjogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHJpdmF0ZSBsYXN0QW5pbWF0aW9uSWQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgc2VydmljZTogUm91bmRQcm9ncmVzc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBlYXNpbmc6IFJvdW5kUHJvZ3Jlc3NFYXNlLFxuICAgIEBJbmplY3QoUk9VTkRfUFJPR1JFU1NfREVGQVVMVFMpIHByaXZhdGUgZGVmYXVsdHM6IFJvdW5kUHJvZ3Jlc3NEZWZhdWx0cyxcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lXG4gICkge31cblxuICAvKiogQW5pbWF0ZXMgYSBjaGFuZ2UgaW4gdGhlIGN1cnJlbnQgdmFsdWUuICovXG4gIHByaXZhdGUgX2FuaW1hdGVDaGFuZ2UoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBmcm9tICE9PSAnbnVtYmVyJykge1xuICAgICAgZnJvbSA9IDA7XG4gICAgfVxuXG4gICAgdG8gPSB0aGlzLl9jbGFtcCh0byk7XG4gICAgZnJvbSA9IHRoaXMuX2NsYW1wKGZyb20pO1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlSW5WYWx1ZSA9IHRvIC0gZnJvbTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNlbGYuZHVyYXRpb247XG5cbiAgICAvLyBBdm9pZCBmaXJpbmcgY2hhbmdlIGRldGVjdGlvbiBmb3IgZWFjaCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lcy5cbiAgICBzZWxmLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5zZXJ2aWNlLmdldFRpbWVzdGFtcCgpO1xuICAgICAgICBjb25zdCBpZCA9ICsrc2VsZi5sYXN0QW5pbWF0aW9uSWQ7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IE1hdGgubWluKHNlbGYuc2VydmljZS5nZXRUaW1lc3RhbXAoKSAtIHN0YXJ0VGltZSwgZHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IGVhc2luZ0ZuID0gc2VsZi5lYXNpbmdbc2VsZi5hbmltYXRpb24gYXMga2V5b2YgUm91bmRQcm9ncmVzc0Vhc2VdO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWFzaW5nRm4oY3VycmVudFRpbWUsIGZyb20sIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKTtcblxuICAgICAgICAgIHNlbGYuX3VwZGF0ZVBhdGgodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHNlbGYub25SZW5kZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlbGYub25SZW5kZXIuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlkID09PSBzZWxmLmxhc3RBbmltYXRpb25JZCAmJiBjdXJyZW50VGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXkgPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoc3RhcnQsIHRoaXMuYW5pbWF0aW9uRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHRoZSBwYXRoIGFwcGVyYW5jZS4gKi9cbiAgcHJpdmF0ZSBfdXBkYXRlUGF0aCh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgY29uc3QgYXJjID0gdGhpcy5zZXJ2aWNlLmdldEFyYyh2YWx1ZSwgdGhpcy5tYXgsIHRoaXMucmFkaXVzIC0gdGhpcy5zdHJva2UgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cywgdGhpcy5zZW1pY2lyY2xlKTtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGgubmF0aXZlRWxlbWVudDtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSByb3VuZGVkIGxpbmUgY2FwIHdoZW4gdGhlIHZhbHVlIGlzIHplcm8sXG4gICAgICAvLyBiZWNhdXNlIFNWRyB3b24ndCBhbGxvdyBpdCB0byBkaXNhcHBlYXIgY29tcGxldGVseS5cbiAgICAgIGNvbnN0IGxpbmVjYXAgPSB0aGlzLnJvdW5kZWQgJiYgdmFsdWUgPiAwID8gJ3JvdW5kJyA6ICcnO1xuXG4gICAgICAvLyBUaGlzIGlzIGNhbGxlZCBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZSBzbyBhdm9pZFxuICAgICAgLy8gdXBkYXRpbmcgdGhlIGxpbmUgY2FwIHVubGVzcyBpdCBoYXMgY2hhbmdlZC5cbiAgICAgIGlmIChsaW5lY2FwICE9PSB0aGlzLmN1cnJlbnRMaW5lY2FwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmVjYXAgPSBsaW5lY2FwO1xuICAgICAgICBwYXRoLnN0eWxlLnN0cm9rZUxpbmVjYXAgPSBsaW5lY2FwO1xuICAgICAgfVxuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGFyYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENsYW1wcyBhIHZhbHVlIGJldHdlZW4gdGhlIG1heGltdW0gYW5kIDAuICovXG4gIHByaXZhdGUgX2NsYW1wKHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWx1ZSB8fCAwLCB0aGlzLm1heCkpO1xuICB9XG5cbiAgLyoqIERldGVybWluZXMgdGhlIFNWRyB0cmFuc2Zvcm1zIGZvciB0aGUgPHBhdGg+IG5vZGUuICovXG4gIGdldFBhdGhUcmFuc2Zvcm0oKTogc3RyaW5nfG51bGwge1xuICAgIGNvbnN0IGRpYW1ldGVyID0gdGhpcy5fZ2V0RGlhbWV0ZXIoKTtcblxuICAgIGlmICh0aGlzLnNlbWljaXJjbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb2Nrd2lzZVxuICAgICAgICA/IGB0cmFuc2xhdGUoMCwgJHtkaWFtZXRlcn0pIHJvdGF0ZSgtOTApYFxuICAgICAgICA6IGB0cmFuc2xhdGUoJHtkaWFtZXRlciArICcsJyArIGRpYW1ldGVyfSkgcm90YXRlKDkwKSBzY2FsZSgtMSwgMSlgO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY2xvY2t3aXNlKSB7XG4gICAgICByZXR1cm4gYHNjYWxlKC0xLCAxKSB0cmFuc2xhdGUoLSR7ZGlhbWV0ZXJ9IDApYDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBSZXNvbHZlcyBhIGNvbG9yIHRocm91Z2ggdGhlIHNlcnZpY2UuICovXG4gIHJlc29sdmVDb2xvcihjb2xvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLnJlc29sdmVDb2xvcihjb2xvcik7XG4gIH1cblxuICAvKiogQ2hhbmdlIGRldGVjdGlvbiBjYWxsYmFjay4gKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGVDaGFuZ2UoY2hhbmdlcy5jdXJyZW50LnByZXZpb3VzVmFsdWUsIGNoYW5nZXMuY3VycmVudC5jdXJyZW50VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVQYXRoKHRoaXMuY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIERpYW1ldGVyIG9mIHRoZSBjaXJjbGUuICovXG4gIF9nZXREaWFtZXRlcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyAqIDI7XG4gIH1cblxuICAvKiogVGhlIENTUyBoZWlnaHQgb2YgdGhlIHdyYXBwZXIgZWxlbWVudC4gKi9cbiAgX2dldEVsZW1lbnRIZWlnaHQoKTogc3RyaW5nfG51bGwge1xuICAgIGlmICghdGhpcy5yZXNwb25zaXZlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuc2VtaWNpcmNsZSA/IHRoaXMucmFkaXVzIDogdGhpcy5fZ2V0RGlhbWV0ZXIoKSkgKyAncHgnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIFZpZXdib3ggZm9yIHRoZSBTVkcgZWxlbWVudC4gKi9cbiAgX2dldFZpZXdCb3goKTogc3RyaW5nIHtcbiAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMuX2dldERpYW1ldGVyKCk7XG4gICAgcmV0dXJuIGAwIDAgJHtkaWFtZXRlcn0gJHt0aGlzLnNlbWljaXJjbGUgPyB0aGlzLnJhZGl1cyA6IGRpYW1ldGVyfWA7XG4gIH1cblxuICAvKiogQm90dG9tIHBhZGRpbmcgZm9yIHRoZSB3cmFwcGVyIGVsZW1lbnQuICovXG4gIF9nZXRQYWRkaW5nQm90dG9tKCk6IHN0cmluZ3xudWxsIHtcbiAgICBpZiAodGhpcy5yZXNwb25zaXZlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW1pY2lyY2xlID8gJzUwJScgOiAnMTAwJSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsIjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIFthdHRyLnZpZXdCb3hdPVwiX2dldFZpZXdCb3goKVwiPlxuICA8Y2lyY2xlXG4gICAgZmlsbD1cIm5vbmVcIlxuICAgIFthdHRyLmN4XT1cInJhZGl1c1wiXG4gICAgW2F0dHIuY3ldPVwicmFkaXVzXCJcbiAgICBbYXR0ci5yXT1cInJhZGl1cyAtIHN0cm9rZSAvIDJcIlxuICAgIFtzdHlsZS5zdHJva2VdPVwicmVzb2x2ZUNvbG9yKGJhY2tncm91bmQpXCJcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoXT1cInN0cm9rZVwiLz5cblxuICA8cGF0aFxuICAgICNwYXRoXG4gICAgZmlsbD1cIm5vbmVcIlxuICAgIFtzdHlsZS5zdHJva2Utd2lkdGhdPVwic3Ryb2tlXCJcbiAgICBbc3R5bGUuc3Ryb2tlXT1cInJlc29sdmVDb2xvcihjb2xvcilcIlxuICAgIFthdHRyLnRyYW5zZm9ybV09XCJnZXRQYXRoVHJhbnNmb3JtKClcIi8+XG48L3N2Zz5cbiJdfQ==